<body>
<p>A lightweight MVC framework.</p>

<p>Explain the similarities to JSF but also the advantage over it.</p>
<p>Give an example scenario and how it would play out in this and also JSF</p>

<h1>To do</h1>
<ol>
<li>Allow null to be returned from controller methods to just redisplay the previous view?</li>
<li>Ensure global resolutions are handled properly</li> 
<li>Cater for storing the view config(s) in progress so that they can be resumed in the event of failure (low priority)</li>
</ol>

<h1>Historical notes</h1>
<p>Make sure the strategy for view creation is encapsulated.</p>

<p>In terms of flexible view composition, will need decorators that implement the necessary view interfaces, and then
probably configure those through spring or another easily configurable factory mechanism, telling it which is
the decorated component which e.g. really holds the list selection model.</p>

<p>That means that a flow would have a step of loading the object in question, then progressing through several views 
which do not retrieve the model but only manipulate it in transient
storage, then to a controller which validates / saves but has no view, and returns a forward to a new view.<p/>

<p>We can then use e.g. jBPM to handle the page flow, maybe even just using jPDL directly, as Seam does.</p>

<p>One of the really nice things about using jBPM would be that after every view, the updated model could be stored as a 
process variable, allowing the process to be resumed at any stage
without having persisted the object to the main database.  
Obviously, a stale object check would have to be done before allowing resumption of that process, otherwise it would be
invalid.  And actually, we wouldn't need to use jBPM for that.  We could just have our own mechanism.</p>

<h2>Global level actions</h2>
<p>Need to implement the concept of global actions, which are always there, 
but which may be delegated to the controller of the currently active view</p>

<h2>Areas of further research</h2>
<ul>
<li>General MVC theory research</li>
<li>Existing Web MVC frameworks</li>
<li>Any GUI MVC frameworks such as Spring Rich Client</li>
</ul>

<h2>Current thoughts</h2>
Whether to convert to a JSF style, where the view simply pulls what it needs from a named configured object, and also
binds to those objects.  Actions are also routed through managed objects, which then return the logical outcome
which is then mapped to next view.
<p/>
Nice things about this - it imposes no particular API on the controllers, facilitating their re-use across
different MVC paradigms.
<p/>
Bad things - an action goes straight into a controller, such as 'orderController.save'.  What if a customer wants
to put a validation view into the flow before the save.  As well as changing the flow configuration, you would need
to write a different implementation of the controller which did not save but instead returned a logical outcome
of validate, which then routed to the validate view.  Better that the SAVE action from the original view is intercepted
directly by the framework, which can then simply look at the config to work out that it goes directly to a validation
view before then actually going to the save controller.
<p/>
So the JSF style couples the controllers more tightly into the flow.  Reading from managed objects by the view is fine,
but having managed beans listen directly to the actions from the view is not.
<p/>
If the framework instead handles actions from the view, then the controllers become part of the flow, which is the
advantage I am after.  Binding could still be done to managed objects, it would just be case of those having to 
expose data to other controllers which need it.  For instance, the extra validation view would need access to the model
to perform its validation.
<p/>
Also, might need multiple listeners on a model, so that a custom view for a customer can react to model
changes without modifying the core components.
<p/>
There are two different types of update:
<ol>
<li>updates that do not represent a navigation intention, such as changing the filter criteria
for a table model.  That actions can go straight to the managed bean, which does its update and fires a model changed
event, which the views respond to.  In JSF, this is handled by returning a null navigation string from the action
handler method, which means redisplay the same view.  But that doesn't sit nicely with partial page updates?
UPDATE - this can be handled directly in the view.
</li>
<li>updates that represent a navigation intention.  These need to be captured by the framework, not bound directly
to a managed object, so that a specialised page flow does not require changes to the managed objects.</li>
</ol>
<p/>
<h2>A scenario</h2>
In a standard flow, sales order details are entered.  Pressing the SAVE button causes a validation controller to be invoked.
If the validation controller has an outcome of SUCCESS, the system should navigate to the order list view.
<p/>
Let's say that for client X, a specialised authorisation number is needed when the order value is greater than
GBP 1000.  
<p/>
When SAVE is pressed from the order edit view, a new controller needs to be invoked which checks the order value,
and if the value is greater than GBP 1000, causes a special view to be displayed.  When SAVE is pressed from this view,
a validation controller needs to be invoked for that view.  Only if that returns SUCCESS should the control pass
to the standard validation controller for the order.  If that returns SUCCESS, then we go back to the list panel.
<p/>
Let's consider how this would be implemented with JSF.  The SAVE action would be bound to <code>#{orderController.validate}
</code>.  <code>orderController</code> is a managed bean with a certain class.  I need to be able to create my customised
flow without changing my standard view, because that would be a maintenance nightmare.  So I would need to override 
the implementation class for <code>orderController</code>.  This gives me several problems:
<ol>
<li>There is no inheritance mechanism for JSF managed bean definitions(??) - my web app simply has a set of navigation rules.  Perhaps
I can write a custom bean resolver??</li>
<li>Being forced to override the definition of that bean is bad, because that bean may have many operations that I need to
wrap.  Doing it by inheritance would be bad, for all the normal reasons (fragile inheritance hierarchies).  Doing it by
encapsulation is also bad - I have to keep wrapping new methods added to the standard bean.  It's just more work than
I want.  Suddenly, a class that should be very simple has to become complex.</li>
</ol>
So instead, I want navigation intents to perform binding to the managed objects, but then to simply go into the page flow mechanism,
to invoke whatever managed bean I want (decouple that from the view)
The custom bean can then retrieve whatever context objects (managed beans) it wants to do the job.
</body>